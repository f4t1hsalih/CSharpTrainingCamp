# ğŸš€ C# EÄÄ°TÄ°M KAMPI PROJELERÄ°

Bu repo, Murat YÃ¼cedaÄŸ'Ä±n eÄŸitmenliÄŸinde tamamladÄ±ÄŸÄ±m C# EÄŸitim KampÄ± boyunca geliÅŸtirdiÄŸim ilk 9 projeyi iÃ§ermektedir. Her bir proje, programlama becerilerimi geliÅŸtirmeme katkÄ±da bulundu. AÅŸaÄŸÄ±da projelere dair teknik ayrÄ±ntÄ±larÄ± bulabilirsiniz:

## ğŸŒŸ Proje 1: Merhaba DÃ¼nya!(MainSubjects)
Konsola metin yazdÄ±rmayÄ± Ã¶ÄŸrendim. **Console.WriteLine()** komutunu kullanarak basit yazdÄ±rma iÅŸlemlerini gerÃ§ekleÅŸtirdim ve temel C# program yapÄ±sÄ±nÄ± anlamaya baÅŸladÄ±m. ğŸ’»

## ğŸŒŸ Proje 2: DeÄŸiÅŸkenler(Variables)
**int**, **string**, **double** gibi farklÄ± veri tÃ¼rlerinde deÄŸiÅŸkenler tanÄ±mlamayÄ± ve bu deÄŸiÅŸkenler Ã¼zerinde iÅŸlem yapmayÄ± deneyimledim. Veri tÃ¼rlerinin mantÄ±ÄŸÄ±nÄ± kavramaya Ã§alÄ±ÅŸtÄ±m. ğŸ” 

## ğŸŒŸ Proje 3: Karar YapÄ±larÄ± (MakingDecision)
**If-else** yapÄ±larÄ±yla farklÄ± koÅŸullar altÄ±nda nasÄ±l karar verileceÄŸini uyguladÄ±m. ProgramÄ±n koÅŸullara gÃ¶re nasÄ±l tepki vereceÄŸini gÃ¶zlemleyerek karar yapÄ±larÄ±nÄ±n iÅŸlevini Ã¶ÄŸrendim. ğŸ¯

## ğŸŒŸ Proje 4: DÃ¶ngÃ¼ler (Loops)
**for** ve **while** dÃ¶ngÃ¼lerini kullanarak tekrar eden iÅŸlemleri otomatikleÅŸtirdim. BÃ¼yÃ¼k veri setlerini dÃ¶ngÃ¼ler yardÄ±mÄ±yla iÅŸleyerek dÃ¶ngÃ¼lerin gÃ¼cÃ¼nÃ¼ keÅŸfettim. ğŸ”

## ğŸŒŸ Proje 5: DÃ¶ngÃ¼ler Ä°le YÄ±ldÄ±z OluÅŸturma (LoopsWithStars)
**for** dÃ¶ngÃ¼sÃ¼ kullanarak -Dik ÃœÃ§gen, -Ters Dik ÃœÃ§gen, -YarÄ±m Elmas, -Piramit, -Ters Piramit, ve -Elmas ÅŸekli yapmayÄ± Ã¶ÄŸrendim. ğŸ”

## ğŸŒŸ Proje 6: Diziler (Arrays)
Birden fazla deÄŸeri tek bir dizi iÃ§erisinde saklamayÄ± ve dÃ¶ngÃ¼lerle bu deÄŸerlere eriÅŸmeyi Ã¶ÄŸrendim. BÃ¶ylece daha organize bir veri yapÄ±sÄ±na sahip olmayÄ± keÅŸfettim. ğŸ§®

## ğŸŒŸ Proje 7: Foreach DÃ¶ngÃ¼sÃ¼(Foreach)
**foreach** dÃ¶ngÃ¼sÃ¼ ile bir sÄ±nav simÃ¼lasyonu oluÅŸturdum. Ã–ÄŸrencilerin sÄ±nav notlarÄ±nÄ± alarak ortalamalarÄ±nÄ± hesapladÄ±m ve sonuÃ§larÄ±na gÃ¶re baÅŸarÄ± durumlarÄ±nÄ± belirledim. ğŸ“

## ğŸŒŸ Proje 8: Metotlar (Methods)
KodlarÄ±mÄ± daha modÃ¼ler hale getirmek iÃ§in metotlar oluÅŸturdum. Parametre alan ve sonuÃ§ dÃ¶ndÃ¼ren metotlarla Ã§alÄ±ÅŸarak kodun okunabilirliÄŸini ve tekrar kullanÄ±labilirliÄŸini artÄ±rdÄ±m. ğŸ› ï¸

## ğŸŒŸ Proje 9: SQL BaÄŸlantÄ±sÄ± ve ADO.NET
**ADO.NET** aracÄ±lÄ±ÄŸÄ±yla SQL veritabanÄ±na baÄŸlanmayÄ± Ã¶ÄŸrendim. VeritabanÄ±ndaki tablo verilerini listeleyip SQL sorgularÄ± ile veri Ã§ekme iÅŸlemlerini gerÃ§ekleÅŸtirdim. ğŸ’½

## ğŸŒŸ Proje 10: CRUD Ä°ÅŸlemleri
**CRUD** iÅŸlemlerini sÄ±rasÄ±yla tamamladÄ±m. (**C** - Create) Insert ile veri kaydettik, (**R** - Read) Write ile veri listeledik, (**U** - Update) Update ile veritabanÄ±nda bulunan bir verinin deÄŸerlerini gÃ¼ncelledik ve (**D** - Delete) Delete iÅŸlemi ile de veri silmeyi Ã¶ÄŸrendik. ğŸ“

## ğŸŒŸ Proje 11: OOP ve N KatmanlÄ± Mimari
**N KatmanlÄ± Mimari** ile **EntityLayer** - **DataAccessLayer** - **BusinessLayer** - **PresentationLayer** oluÅŸturduk. Bu katmanlarÄ±n her biri kendine Ã¶zgÃ¼ iÅŸlemleri yapmak iÃ§in oluÅŸturuldu. **EntityLayer**'da Concrete klasÃ¶rÃ¼ oluÅŸturuldu ve iÃ§erisinde Class'lar ve Class'lar iÃ§erisinde de Property'ler tanÄ±mlandÄ±. Bu Class'lar VeritabanÄ±ndaki her bir tabloya denk gelir ve Class'lar iÃ§erisinde bulunan Property'ler de VeritabanÄ±nda bulunan tablolar iÃ§erisindeki stunlara karÅŸÄ±lÄ±k gelir. ğŸ“¦

### Access Modifiers
Access Modifiers (EriÅŸim Belirleyiciler) C# dilinde dÃ¶rt temel eriÅŸim belirleyici ile kullanÄ±lÄ±r:

1. **public**: SÄ±nÄ±f veya Ã¼ye elemanÄ±na tÃ¼m katmanlardan eriÅŸilebilir.
2. **private**: YalnÄ±zca tanÄ±mlandÄ±ÄŸÄ± sÄ±nÄ±fÄ±n iÃ§erisinde eriÅŸilebilir.
3. **protected**: YalnÄ±zca tanÄ±mlandÄ±ÄŸÄ± sÄ±nÄ±f ve o sÄ±nÄ±ftan tÃ¼retilen sÄ±nÄ±flardan eriÅŸilebilir.
4. **internal**: Sadece aynÄ± proje (assembly) iÃ§erisinde eriÅŸim saÄŸlanabilir.

## ğŸŒŸ Proje 12: OOP ModÃ¼lÃ¼ â€“ Data Access KatmanÄ± ve Context SÄ±nÄ±fÄ±
**Context** sÄ±nÄ±fÄ±nÄ± projeye ekledik ve `DbSet<>` kullanarak veritabanÄ±nda oluÅŸturulacak sÄ±nÄ±flarÄ± tanÄ±mladÄ±k. AyrÄ±ca, bazÄ± sÄ±nÄ±flar iÃ§in bire-Ã§ok iliÅŸki tanÄ±mlamalarÄ±nÄ± gerÃ§ekleÅŸtirdik. Bu yapÄ±, veritabanÄ± iliÅŸkilerini daha dÃ¼zenli ve yÃ¶netilebilir hale getirirken, veritabanÄ±nÄ±n oluÅŸturulabilmesi iÃ§in **app.config** dosyasÄ±nda **connectionStrings** bÃ¶lÃ¼mÃ¼nÃ¼ tanÄ±mladÄ±k. ğŸš€

## ğŸŒŸ Proje 13: OOP ModÃ¼lÃ¼ â€“ Migration Ä°ÅŸlemleri ve Abstract Interface'ler
**Migration** iÅŸlemlerinin nasÄ±l kullanÄ±ldÄ±ÄŸÄ±nÄ± ve ne iÅŸe yaradÄ±ÄŸÄ±nÄ± Ã¶ÄŸrendik. Projemizde oluÅŸturduÄŸumuz entity'leri `update-database` komutu ile veritabanÄ±na yansÄ±ttÄ±k. ArdÄ±ndan design pattern kavramÄ±nÄ± inceledik ve `IGenericDal` interface'i ile generic bir yapÄ± oluÅŸturduk. DataAccessLayer'da bulunan `Abstract` klasÃ¶rÃ¼ iÃ§erisinde her entity iÃ§in bir interface tanÄ±mlayÄ±p, bu interface'lerin `IGenericDal`'dan miras almasÄ±nÄ± saÄŸladÄ±k. âš™ï¸

## ğŸŒŸ Proje 14: ORM YapÄ±sÄ±: Entity Framework DB First ve Model OluÅŸturma
**Entity Framework**'Ã¼n ORM (Object-Relational Mapping) yeteneklerinden nasÄ±l yararlanabileceÄŸimizi ve veri tabanÄ± iÅŸlemlerini nasÄ±l kolaylaÅŸtÄ±rabileceÄŸimizi Ã¶ÄŸrendik. **DB First** yaklaÅŸÄ±mÄ±yla Ã¶nceden var olan bir veritabanÄ±nÄ± projemize dahil ettik ve bu yaklaÅŸÄ±mÄ±n detaylarÄ±na deÄŸindik.

Entity Framework'Ã¼n **DB First** yÃ¶ntemi, mevcut bir veritabanÄ± yapÄ±sÄ±na dayalÄ± olarak otomatik olarak modeller oluÅŸturmak iÃ§in kullanÄ±lan bir yÃ¶ntemdir. Bu projede, Ã¶nceden oluÅŸturduÄŸumuz veritabanÄ±nÄ± DB First yaklaÅŸÄ±mÄ±yla **Model1.edmx** dosyasÄ± Ã¼zerinden modelledik. **Model1.edmx** dosyasÄ±, veritabanÄ±ndaki tablolar, iliÅŸkiler ve diÄŸer nesneleri gÃ¶rsel bir ÅŸekilde incelememizi saÄŸladÄ±. Bu dosyayÄ± kullanarak veritabanÄ±ndaki varlÄ±klar (entities) ile .NET nesneleri arasÄ±nda baÄŸlantÄ± kurmamÄ±z mÃ¼mkÃ¼n hale geldi.ğŸ“Š

## ğŸŒŸ Proje 15: Entity Framework MetotlarÄ± ile Proje UygulamasÄ±
**Entity Framework** metodlarÄ±nÄ± bir Windows Form uygulamasÄ±nda kullandÄ±k. Uygulamada:  
- **DataGridView** Ã¼zerinden veri gÃ¶rÃ¼ntÃ¼leme,  
- **TextBox** aracÄ±lÄ±ÄŸÄ±yla girilen verileri veritabanÄ±na kaydetme,  
- **ID** ile veri Ã§ekme ve dÃ¼zenleme iÅŸlemlerini gerÃ§ekleÅŸtirdik.  

AyrÄ±ca, **SSMS** kullanarak veritabanÄ±na yeni bir tablo ekledik ve bu tabloyu **Model1.edmx** dosyamÄ±za *Update Model from Database* seÃ§eneÄŸi ile dahil ettik. BÃ¶ylece veritabanÄ± ile uygulama arasÄ±nda entegrasyonu saÄŸladÄ±k. ğŸ”„

## ğŸŒŸ Proje 16: Entity Framework: Tur Projesi Location Ä°ÅŸlemleri
**Location** tablosu iÃ§in bir form oluÅŸturduk. Bu formda ÅŸu iÅŸlemleri gerÃ§ekleÅŸtirdik:

- KayÄ±tlarÄ± **listeleme**
- Yeni kayÄ±t **ekleme**  
- Mevcut kayÄ±tlarÄ± **silme**  
- KayÄ±t **gÃ¼ncelleme**  
- **ID'ye gÃ¶re** veri getirme  
- **ID'ye gÃ¶re** tabloya veri listeleme  

Bu ders, bir Ã¶nceki dersin konularÄ±nÄ± pekiÅŸtirme amacÄ±yla yapÄ±lan bir Ã§alÄ±ÅŸma oldu. ğŸ”„

## ğŸŒŸ Proje 17: Entity Framework ve LINQ ile Ä°statistik Takibi
Bu derste, **Entity Framework** ve **LINQ** sorgularÄ± kullanÄ±larak bir Windows Form uygulamasÄ±nda veri tabanÄ±ndan alÄ±nan istatistikler listelendi.  
Ä°statistikler, dinamik olarak oluÅŸturulup uygulama arayÃ¼zÃ¼nde gÃ¶sterildi.  
BazÄ± istatistikler iÃ§in **alt sorgular** kullanÄ±ldÄ±.

![Proje GÃ¶rseli](Pictures/Lecture14-FrmStatistics.png)

## ğŸŒŸ Proje 18: EntityState KomutlarÄ±, Generic Repository SÄ±nÄ±fÄ± ve EF SÄ±nÄ±flarÄ± 
**DataAccessLayer** iÃ§inde  Repository isimli bir klasÃ¶r oluÅŸturduk ve iÃ§erisine GenericRepository sÄ±nÄ±fÄ±nÄ± ekledik. Bu sÄ±nÄ±f ile CRUD iÅŸlemlerini genel bir sÄ±nÄ±fa toplamÄ±ÅŸ olduk. Entity Framework ve LINQ sorgularÄ± kullanÄ±larak CRUD iÅŸlemleri baÅŸarÄ±yla tamamladÄ±k. 

Daha sonra, EntityFramework isimli bir klasÃ¶r oluÅŸturduk. Bu klasÃ¶r iÃ§erisinde her bir entity iÃ§in Ef...Dal ÅŸeklinde sÄ±nÄ±flar tanÄ±mladÄ±k. Bu sÄ±nÄ±flar, GenericRepository ve I...Dal ÅŸeklinde oluÅŸturulmuÅŸ ilgili interface'ten miras aldÄ±.ğŸ“Š

## ğŸŒŸ Proje 19: Business KatmanÄ± ve Logic KurallarÄ±
**BusinessLayer** iÃ§inde **Abstract** ve **Concrete** adÄ±nda iki klasÃ¶r oluÅŸturduk. 

- **Abstract** klasÃ¶rÃ¼nde bir **GenericService** interface'i tanÄ±mladÄ±k. Daha sonra bu generic servisten miras alarak her bir entity iÃ§in ayrÄ± ayrÄ± service interface'leri oluÅŸturduk.  
- **Concrete** klasÃ¶rÃ¼nde ise **Abstract** klasÃ¶rÃ¼nde tanÄ±mlanan her bir interface iÃ§in bir **Manager** sÄ±nÄ±fÄ± oluÅŸturduk. Bu sÄ±nÄ±flar, ilgili interface'lerden miras aldÄ±.  

ArdÄ±ndan **Dependency Injection** kullanarak, her bir **Manager** sÄ±nÄ±fÄ±nÄ±n `constructor` metodunda gerekli database atamalarÄ±nÄ± gerÃ§ekleÅŸtirdik. Her bir **Manager** sÄ±nÄ±fÄ±nÄ±, **EntityFramework** metodlarÄ±ndan faydalanarak doldurduk. AyrÄ±ca, **BusinessLayer**'Ä±n validasyon iÅŸlemleri iÃ§in kullanÄ±ldÄ±ÄŸÄ±nÄ± ve burada oluÅŸturduÄŸumuz **Manager** sÄ±nÄ±flarÄ± aracÄ±lÄ±ÄŸÄ±yla bu validasyon iÅŸlemlerini nasÄ±l gerÃ§ekleÅŸtirebileceÄŸimizi Ã¶ÄŸrendik. âœ…

## ğŸŒŸ Proje 20: Dependency Injection (BaÄŸÄ±mlÄ±lÄ±k Enjeksiyonu)
**Dependency Injection (DI)** nedir, projelerde ne iÃ§in ve nasÄ±l kullanÄ±lÄ±r gibi konularda bilgi aldÄ±k. **Constructor** metodunun ne iÅŸe yaradÄ±ÄŸÄ±nÄ±, neden ve nasÄ±l kullanÄ±ldÄ±ÄŸÄ±nÄ± inceledik. Projemizde oluÅŸturduÄŸumuz constructor metod sayesinde, form oluÅŸturulurken ilgili servisi Ã§aÄŸÄ±rdÄ±k ve manuel olarak EfCategoryDal sÄ±nÄ±fÄ±nÄ± enjekte ettik.

SonrasÄ±nda, **Category (Kategori)** entityâ€™si iÃ§in bir form oluÅŸturduk. Bu form Ã¼zerinde ÅŸu iÅŸlemleri gerÃ§ekleÅŸtirdik:
- Veri ekleme,  
- Veri silme,  
- Veri gÃ¼ncelleme,  
- Veri listeleme,  
- IDâ€™ye gÃ¶re getirme iÅŸlemleri. ğŸš€

## ğŸŒŸ Proje 21: Entity'e Ã–zgÃ¼ Metot Yazmak
Bu projede, **ÃœrÃ¼nler** iÃ§in bir form tasarlayÄ±p listeleme iÅŸlemlerini gerÃ§ekleÅŸtirdik. Listeleme sÄ±rasÄ±nda, Ã¼rÃ¼nlerin baÄŸlÄ± olduÄŸu kategorilerde yalnÄ±zca `CategoryId` gÃ¶rÃ¼nÃ¼yordu. Bu durumu dÃ¼zeltmek iÃ§in, **Product** entity'sine Ã¶zgÃ¼ bir `GetProductsWithCategory` metodu yazdÄ±k. 

Bu metod sayesinde, artÄ±k Ã¼rÃ¼nlerin listelenmesi sÄ±rasÄ±nda **Kategori AdÄ±** gÃ¶rÃ¼ntÃ¼leniyor. Bunu baÅŸarmak iÃ§in, `Product` entity'sine Ã¶zel **ProductWithCategoryDTO** adÄ±nda bir DTO sÄ±nÄ±fÄ± tanÄ±mladÄ±k. DTO Ã¼zerinden gerekli deÄŸerleri atayarak kullanÄ±cÄ±ya kategori adÄ±nÄ± gÃ¶sterdik. ğŸ› ï¸

ğŸ’¡ Bu yapÄ±, verilerin daha anlaÅŸÄ±lÄ±r ve kullanÄ±cÄ± dostu bir ÅŸekilde sunulmasÄ±nÄ± saÄŸladÄ±. AyrÄ±ca, katmanlÄ± mimaride entity'lere Ã¶zel iÅŸlemler iÃ§in esnek bir altyapÄ± oluÅŸturduk.

---

## ğŸ“‚ Metod Ä°Ã§eriÄŸi  
```csharp
public List<ProductWithCategoryDto> GetProductsWithCategory()
{
    var values = _database.Products
        .Include(x => x.Category)
        .Select(x => new ProductWithCategoryDto
        {
            Id = x.Id,
            Name = x.Name,
            Stock = x.Stock,
            Price = x.Price,
            Description = x.Description,
            CategoryName = x.Category.Name
        })
        .ToList();

    return values;
}
```

## ğŸŒŸ Proje 22: C# ile Dapper KullanÄ±mÄ±  

Bu derste, **FrmProduct** iÃ§in eksik kalan "ID'ye gÃ¶re getir", "Ekle" ve "GÃ¼ncelle" iÅŸlemlerini kodladÄ±k. Dapper hakkÄ±nda bilgi edinerek, yeni bir proje oluÅŸturup **Dapper** paketini kurduk. Proje iÃ§ine **Repository** ve **DTO** klasÃ¶rleri ekledik. DTO hakkÄ±nda bilgi alarak, **ResultDTO**, **AddDTO** ve **UpdateDTO** sÄ±nÄ±flarÄ±nÄ± yazdÄ±k. Repository kÄ±smÄ±nda ise asenkron metodlar hakkÄ±nda bilgi edindik ve asenkron bir interface ile bu interfaceden miras alan bir class oluÅŸturduk. ğŸ› ï¸


